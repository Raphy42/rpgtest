<link rel=import href="adebray-color/color-hash.html">
<link rel=import href="adebray-color/color-dot.html">

<dom-module id="adebray-skill-tree">
	<template>
		<style>
			:host {
				display: inline-block;
			}
		</style>


		<div id=head>
			<color-hash></color-hash>
		</div>

		<!-- <div class=centered>
			<div id='container'></div>
		</div> -->

	</template>
	<script>
	var n
	var n2
	Polymer({
		is: 'adebray-skill-tree',

		properties: {
			depth: Number
		},

		attached: function () {
			let flatted = (o) => Object.keys(o).map( k => Object.keys(o[k]).map( e => {
				k = k.match(/\w+/)[0]
				e = e.toLowerCase()
				return `${k}.${e}`
			}))

			let test = flatted(Magic).concat( flatted({
				"Combat": {
					// "Bare Hands": null,
					// "Harp": null,
					"Bow": null,
					"Other": null
				}
			}))
			test = [].concat.apply([], test)
			console.log(test.length)

			let harmonizer = new Harmonizer()
			let p = []
			for (var i = 0; i < 360; i += 360 / test.length) {
				p.push( parseInt(i) )
			}

			console.log(p)
			let h = harmonizer.harmonize('#c820f1', p)
			// let colors = Object.keys(Magic).concat(['Combat']).map( e => {
			let colors = test.map( (e, i) => {
				let dot = document.createElement('color-dot')
				dot.customStyle['--custom-color'] = h[i]
				dot.text = e

				this.$.head.appendChild(dot)

				return {
					text: e,
					color: dot.customStyle['--custom-color']
				}
			})
			// console.log(colors)

			var c = document.createElement('canvas')
			var stage = new Konva.Stage({
				container : c,
				width: 800 / 2,
				height: 600 / 2
			})
			layer = new Konva.Layer({
				draggable: true
			})

			let scale = 0.3
			stage.on('contentWheel', (e) => {
				// e.preventDefault()
				console.log(e.evt.deltaY)
				scale += e.evt.deltaY / 100
				layer.scale({x: scale, y: scale})
				layer.draw()
			})

			stage.add(layer)
			layer.scale({x: scale, y: scale})

			let cmp = 0
			let stack = [{
				x: 0,
				y: 0
			}]
			let g_size = 32
			layer.add(new Konva.Rect({
				x: 0,
				y: 0,

				offsetX: g_size / 2,
				offsetY: g_size / 2,
				width: g_size,
				height: g_size,

				fill: 'black',
				// stroke: 'blue',
				// strokeWidth: 10
			}))

			let c_table = {
				0: 30,
				1: 50,
				2: 20
			}

			if ( Object.keys(c_table).reduce( (p, k) => {
				return (p += c_table[k])
			}, 0) != 100)
				console.log('wrong space')

			let tmp_table = {}
			let j = parseInt( Object.keys(c_table)[0] )
			for (var i = 0; i < 100; i++) {
				tmp_table[i] = j
				c_table[j] -= 1
				if (c_table[j] == 0)
					j += 1
			}

			n = n || new FastSimplexNoise({
				// random: () => 0.2
			})
			n2 = n2 || new FastSimplexNoise(() => 1)
			let res = []
			let make_side = (_x, _y, prev = 0, depth = 0) => () => {
				var len = 4

				var callback = []
				for (var i = 0; i < len; i++) {
					let p = (Math.PI * 2 / len) * i

					// let j = parseInt(Math.random() * 100)
					let j = parseInt( n.get2DNoise( _x, _y ) * 100 )
					// let j = parseInt( Math.cos(_x * _x + _y * _y) * 99 )
					j = tmp_table[ Math.abs(j) ]
					let size = g_size * j

					let _size = Math.max(size, prev)
					let __x = _x + Math.round( _size * 2 * Math.cos(p) )
					let __y = _y + Math.round( _size * 2 * Math.sin(p) )

					if ( stack.filter(({x, y}) => x == __x && y == __y ).length == 0 ) {
						let c = colors[ parseInt(Math.abs(n.get2DNoise( __x, __y ) * colors.length)) ]

						layer.add(new Konva.Rect({
							x: __x,
							y: __y,

							offsetX: size / 2,
							offsetY: size / 2,
							width: size,
							height: size,

							fill: c.color,
							// draggable: true
						}))

						// res.push(size + c.color)
					}


					stack.push({
						x: __x,
						y: __y,
					})

					if (depth < this.depth)
						callback.push( make_side(__x, __y, size, depth + 1) )
				}

				callback.forEach(e => e())
			}

			make_side(0, 0, g_size)()

			layer.draw()
			// console.log(layer.children.length)
			let d = document.createElement('div')
			d.innerHTML = JSON.stringify(res.reduce( (p, e) => {
				if (!p[e])
					p[e] = 1
				else
					p[e] += 1
				return p
			}, {}), undefined, '<br>')
			this.appendChild(d)

			layer.x( stage.width() / 2)
			layer.y( stage.height() / 2)
			layer.draw()

			let im = document.createElement('img')
			im.onload = () => this.appendChild(im)
			im.src = stage.toDataURL()
		}


	})
	</script>
</dom-module>
